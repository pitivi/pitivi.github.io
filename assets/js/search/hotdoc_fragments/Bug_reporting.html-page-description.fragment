fragment_downloaded_cb({"url":"Bug_reporting.html#page-description","fragment":"Welcome, testers!\nBug reporting and feature requests are managed with GNOME's\nGitLab. You need to create\nan account to file issues and comment on them. Take a quick look at the\nexisting list of bugs and feature\nrequests to see if\nyour problem has already been reported.\nTo report a bug/problem in the software, create an\nissue.\nIdeally you can describe exactly the steps anyone can follow to\nreproduce the bug. The more details, the better.\nTo be able to reproduce an issue, we might ask you to share sample\nmedia files with us. If the file is too large to attach to the GitLab\nissue, you can use for example Dropbox,\nGoogle Drive, MEGA or\nother service to share such media.\nYou can also share in a similar way a project archive containing the\nproject and all the media is uses:\nIn addition to the project archive, it is extremely helpful to provide\n“scenario” files. These are automatically generated each time you\nuse a project and contain the operations you made. Combined with the\nproject archive, these allow us to perform exactly the actions that have\noccurred to trigger the bug. This makes reproducing the issue on our\nmachines a very easy and reliable process, which saves you a ton of\ntime! Here's how to provide scenario files to facilitate the\nprocess:\nWhen reporting a crash (application window disappears) or a\ndeadlock (application is frozen), we can't do much without a\nback trace.\nFirst try to see if you can locate a coredump file created by your\nsystem automatically when a crash takes place. For example:\nA coredump can be investigated using gdb. Look below for the proper way\nto start gdb, but at the end instead of gdb python3 -ex ... simply run\ngdb python3 ~/coredump.\nAlternatively, if you are missing a coredump, start Pitivi in gdb as\ndescribed below, then try to reproduce the crash.\nFinally, in gdb run bt full to get the back trace for the crash.\nTip: To avoid the need to press Enter to “scroll” in gdb,\nrun set pagination 0.\nFor a deadlock, start Pitivi in gdb as described below, press Ctrl+Z\nand run thread apply all bt to get the backtraces for all the threads.\nInstall the GNOME SDK Debug symbols and update them, see below.\nEnter the sandbox:\nGNOME's Getting Stack Traces has excellent documentation and tips\non the subject, including how to install the relevant debug\npackages. Below is a quick reminder for those already familiar with\nthe process.\nWhen you want to “attach” to an existing Python process (useful for\ndeadlocks, where the application will be hung instead of crashed):\nWhen you want to run Pitivi entirely in gdb from the start:\nWhen you need to know what’s going on inside Pitivi, you can launch it\nwith a debug level. In\nloggable.py,\nthere are six levels: ( ERROR,\nWARN,\nFIXME,\nINFO,\nDEBUG,\nLOG ) = range(1, 7). As such, if you\nwant to see errors and warnings only, you launch\n...and if you want to see everything you do\nIf that's “too much” and you want to focus on particular parts of the\ncode, you can do so. For example, you can get output from the Timeline\nand MediaLibraryWidget classes only:\nHere are various examples of commands you can use to generate detailed\ndebug logs that include not only Pitivi's debug output, but also\nGStreamer's:\nA basic log can be obtained by running:\nTo get debugging information from Non-Linear Engine, you could use:\nThe information most likely to be useful would probably be the debug\ninfo from GES in addition to Pitivi's:\nWhen using GST_DEBUG, the resulting logs will most likely be too\nbig to be attached to a bug report directly. Instead, compress them\n(in gzip, bzip2 or lzma format) before attaching them to a bug report.\nIn the rare cases where a performance problem is caused by our UI code,\nyou can profile Pitivi itself, with this command (and yes,\nJUMP_THROUGH_HOOPS is needed for this case, it is an environment\nvariable of\nbin/pitivi:\nThe resulting pitivi_performance.profile file can then be processed\nto create a visual representation of where the most time was spent and\nwhich functions were called the most often in the code. See also Jeff's\nblog posts on profiling.\n"});