fragment_downloaded_cb({"url":"design/Plugins.html#the-jokosher-way","fragment":"The Jokosher way\nJokosher is an audio production software that uses python+gtk+gstreamer\n(http://www.jokosher.org)\nIts pluggable architecture places plugins into the ./extensions\ndirectory. Plugins can be stored as source .py files or packed into\npython eggs.\nExtension API are provided for inserting menu items inside the main\njokosher menu, as well as functions to control playback, instruments and\nto add new output formats.\nPlugin preferences are stored in the ./extension-config path, with one\nconfig file for each plugin named as the plugin itself. Preferences are\nserialized by pickle into a dictionary of objects; standard methods to\nstore and retrieve keys from the dictionary are available to the plugin\nwriter.\nThe plugin manager install/remove plugins taking care of possible\nconflicts, it also manages the loading/unloading/configuration processes\nfor each plugin, ensuring each plugin is loaded only once (plugins are\ntreated as singletons).\nEach plugin must contain:\nThis approach defines a clear set of API that the plugin can use as\npreferred way to interact with the main application, API are pushed into\nthe plugin when it is activated and a reference to them is usually kept\ninside the plugin though all its lifetime.\nAPI for UI integration allow to insert new menu items, leaving to the\nplugin the responsibility to remove the inserted items when it is\nunloaded. The same logic is applied when additional output formats are\nprovided by the plugin, those must be removed from available output\nformat by the plugin itself when it is deactivated.\nStrength points of the Jokosher approach are a well designed and\nlightweight plugin manager; the possibility to store plugins in python\neggs that simplifies a lot the deployment of new plugins; a clean set of\nAPI the plugin can use to interact with the host application; the\npossibility to add new output formats; the possibility to save plugin's\npreferences without having the plugin care about serialization\nprocedures.\nWeak points of this architecture are a limited UI integration because\nplugins which uses only the API can insert menu items only under the\n“plugin” submenu; the creation of a preferences file for each plugin\navailable could lead to a pollution of config files; leaving to plugins\nthe duty of removing UI enhancements they inserted could lead to waste\nof memory if the plugin writer does not make a good job, a defaulf\napproach for cleaning would be preferable.\n\nsome descriptive fields identifying the name, description and\nversion\nstartup(api) function is called when the plugin is activated,\npassing the whole API set to the the plugin.\nshutdown() function is called when the plugin is deactivated, it\ntakes care of the cleanings.\n\n"});